//mem pause 
//verbosity 2 = 
// logOn
5 
//mem pause
"OptimizeOn" variable
OptimizeOn 1 = 
#if OptimizeOn @
optimizeOn inlineOn
#else
optimizeOff inlineOff
#endif
Root 
"log" variable 
"User" namespace 

// aliases 
// using pause
Debug
//"dbg" ' _dbg alias immediate debugWord
"dbrk" ' <dbg> alias debugWord
"locals" ' localsShow alias
"regs" ' cpuStateShow alias
'nt 'namespaceTreeWithWords alias
'scOn 'dbgSourceCodeOn alias
'scOff 'dbgSourceCodeOff alias

User
"const" ' constant alias
"var" ' variable alias
"wdis" ' wordDisassemble alias

Combinators
"ix" ' call alias immediate
"qEval" ' call alias immediate
"ifte" ' tf3 alias
"ifElse" ' tf3 alias

User
#if 1
: _SMN_ "StartupMacros" ;                           // _SMN_ : string startup macros namespace 
"StartupMacros" namespace                           // create a namespace for string macros to be used 
StartupMacros                                       // switch to that namespace
: Delimiters "/" ;                                  // set delimiters to be used with string macros
// "_startDirectory_" variable                      // created and set in CfrTil_ResetAll_Init
: namespaces _startDirectory_ @ ;                   // this line also works in place of the next line
                                                    // '_startDirectory_' is a variable created in the function 
                                                    // CfrTil_ResetAll_Init in the file init.c
//: namespaces "/usr/local/lib/cfrTil/namespaces" ; // our currently only ?!overloaded!? string macro allowing 
                                                    // us to parameterize the startup; can be properly started 
                                                    // in any directory now if it is installed with 'make install' 
                                                    // in "/usr/local/lib/cfrTil"
// stringMacrosOn                                   // turn on the macros; doesn't work if not initialized like eg. above initialization
                                                    // nb. we don't turn it on here until about line 304
// stringMacrosOff                                  // turn off the macros
#endif
Lexer User 

// nb. there is still some (alot of) old junk here and especially in the test files and some of the comments may not apply anymore ...
// echoOn
// verbosity 1 = 
//autoVarOn
Debug
"DebugFlag" variable
DebugFlag 0 =

Compiler 
// nb : .'"[] : these five characters - dot, tick, quote left bracket, right bracket - .'"[] - are character macros including the brackets they work at the char level in readline
// set up some traditional Forth words from internal primitives
// core internal c defined words : begin _end token _tick _immediate definition compile constant variable alias compileModeOn wordInit wordAdd wordFinish
"'" "tick" find alias _immediate
"immediate" ' _immediate alias _immediate
"compileWord" ' _compileWord alias immediate
"compileCall" ' _compileCall alias immediate
"swap" ' _swap alias immediate
"{" ' begin alias immediate keyword
"end" ' _end alias immediate
"}" ' end alias keyword
"xt@" { xt @ } word immediate // ' definition alias immediate
"_semi" create { xt= wordFinish } xt= wordFinish 
"semi" create { _end _semi } _semi 
";" ' semi alias immediate
":" { compileModeOn sourceCodeInit token create begin } word immediate // begin is not an immediate word
#if 1
: word swap create swap _semi ;  //'word wordDisassemble pause
#else
//: word ( n b ) n @ create b @ _semi ; 'word wordDisassemble pause // works but it is more code
#endif
"xt@" { xt @ } word immediate // ' definition alias immediate
: tick token _tick ;
'ndrop '_ndrop alias immediate 
: ' token _tick ; immediate
// : ' token find ; immediate
Class
'_new 'new alias prefix
C
"typedef" ' type alias
: ;; semi _prefix ; immediate
c_syntaxOn //using
type int ; int.size = 4 ;
type void ; void.size = 0 ;
type char ; char.size = 1 ;
type long ; long.size = 8 ;
type quad ; quad.size = 16 ;
c_syntaxOff

Compiler 
: var: { token dup ";" strcmp } { var } while drop ; immediate // nb : no quotation marks around names
var: DebugFlag classTestRead streamLine doInit1 doDemo doTest doLisp COMBINATOR_TOOKIT doLisp testing testLisp x Zenfone2 ; // _TestDone_ ; 
: nstrcat: "" { token dup ";" strcmp } { strcat " " strcat } while drop ; immediate // nb : no quotation marks around names
"mod" 'modulo alias
// "Preprocessor" class
Lisp
"lambda" "_lambda" find alias // nb! : can't use C/Compiler/Forth ' (tick) in Lisp namespace - it has another meaning there! : this construction also has same meaning

Namespace
: using: { token dup ";" strcmp } { usingFirst } while drop ; // eg - "using: User Lisp ;"
: notUsing: { token dup ";" strcmp } { notUsing } while drop ; 
: usingLast: { token dup ";" strcmp } { usingLast } while drop ; 
notUsing: C_Combinators C_Syntax Lisp ;

System
"Black" 0 const
"Red" 1 const
"Green" 2 const
"Yellow" 3 const
"Blue" 4 const
"Magenta" 5 const
"Cyan" 6 const
"White" 7 const
"Default" 9 const
//: netbeans Blue Default setDebugColors ; : nnb Blue Black setDebugColors ; // netbeans // nnb

Root
"fr" 'fullRestart alias
"ri" 'restartInit alias
//'q 'quit alias
System
"true" 1 const
"false" 0 const
"T" 1 const
"F" 0 const
Io
: _ps printString ; inline
: ps space _ps ;
: prints _ps ;
: pn intPrint ;
: _p intPrint ;
: p space intPrint ;
: hp hex p ;
: print space intPrint ;
"nl" ' newline alias keyword
: _logWrite "cfrTil.log" logWrite ;
: _logAppend "cfrTil.log" logAppend ;

Debug
// make immediate/word immediate - compile time versions of some words
// : d: _dbg ; immediate debugWord // a debugWord has special behavior : doesn't interfere with optimization
: _s stack ; 
: s stack ; immediate
: sinit stackInit ; 
: dcm decimal ; immediate // a non hex interpreted word
//: iun using stack namespaceTree ; immediate
: slp "stack at " ps location stack _pause ;
: sp stack _pause ;
C
: logWrite ( str ) _logWrite nl str @ ps nl ;
: logAppend ( str ) _logAppend nl str @ ps nl ;

Word 
: code definition ;

C
System
: sp ;
scOn //verbosity 3 =
: location filename ps space decimal lineNumber _p "." _ps charNumber _p ;
: pdl  "-----------------------------" ps ;
: pel  "=============================" ps ;
: _source ( addToHistoryFlag  pword )
    { addToHistoryFlag @ } { pword @ sourceAdd } { pword @ sourceDontAdd } ifElse 
;;
: _wdiss ( addToHistoryFlag pword ) 
    nl pel 
    nl "::> 'wdiss' is being called at" _ps location "<::" ps
    _source ( addToHistoryFlag @ pword @ ) nl pdl 
    pword @ wdis 
    "Word :" _ps hex pword p ":: Compiled at :" ps pword @ definition p 
    nl pel nl decimal 
;;
scOff
//: wdiss ( pword ) _wdiss ( 1 pword @ ) ; debugWord    // add wdiss words to history list
: wdiss ( pword ) _wdiss ( 0 pword @ ) ; debugWord      // don't add wdiss words to history list
: wdissl ( pword ) logOn _wdiss ( 0 pword @ ) logOff ; debugWord      // don't add wdiss words to history list
"winfo" ' wdiss alias
// ' wdiss wdiss
: sys mem namespaces words stack using in ; 
'aw 'allWords alias
: stk stack ; //debugWord 
: ti timerInit ;
: ahalt stop ;
: vb ( n ) verbosity n @ = ; : vb3 3 vb ; : vb2 2 vb ; : vb1 1 vb ; : vb0 0 vb ;
: sOff vb1 inlineOff optimizeOff ;
: sOn vb3 inlineOn optimizeOn ;
"ahOn" ' addToHistoryOn alias
"ahOff" ' addToHistoryOff alias
: adps ( s ) alertColors s @ ps defaultColors ;
: ddps ( s ) debugColors s @ ps defaultColors ;
'dbOn var //dbOn 1 = 
#if dbOn @ 
scOn verbosity 3 =
#endif
: _assert0 ( n m ) { n @ m @ != } { nl location hex n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { } ifElse ;
: _assert ( n m ) nl location "- _assert ::" ps { n @ m @ != } { hex n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { " ok" ps } ifElse ;
: _assert1 ( n m str ) { n @ m @ != } { str @ ps "error" ps _info _pause } if ;
//: assert1 ( n m str ) location { n @ m @ != } { nl str @ ps ":>" ps hex n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { str @ ps "ok\n" ps } ifElse ;
: assert1 ( n m str ) location { n @ m @ != } { nl str @ ps ":>" ps hex n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { str @ ps "ok\n" ps } ifElse ;
: assert1s ( s1 s2 str ) { s1 @ s2 @ strcmp } { nl str @ ps "error" ps _info _pause } if ;
: _assert2 ( n m str ) { n @ m @ == } { str @ ps "ok" ps nl } { str @ ps "error" ps _info _pause } ifElse ; 
: assert2 ( n m str ) { n @ m @ == } { nl str @ ps "ok" ps nl } { nl str @ ps "error" ps _info _pause } ifElse ;
: assert0 ( n m ) { n @ m @ != } { nl "error" ps _info _pause } if ; 
"assert" ' assert1 alias
: _assertStkChk ( n m | str )  
#if dbOn @
    _s 
    d: <dbg> { verbosity @ }
#else
    _s
    { verbosity @ }
#endif
    {
        { DebugFlag @ } 
        { 
            debugColors
            str "\n assertStkChk ::" = 
            { n @ m @  == }
            { nl location ":" ps str @ ps "ok" ps nl sp } 
            { tab nl location ":" ps str @ ps alertColors "\n Error!\n" ps hex n @ p "!=" ps m @ p sp nl quit } 
            ifElse 
            defaultColors 
        } 
#if dbOn @
        { nl sp n @ m @ "assertStkChk" <dbg> assert _s }
#else
        { nl sp n @ m @ "assertStkChk" assert }
#endif
        ifElse
        //mem
    } if2 _s nl location nl //_pause
; 
: assertStkChk _assertStkChk ; //stack _pause ; // s ;
scOff
// ' _assertStkChk winfo 
: TODO ( str ) nl pdl nl str @ adps location nl pdl nl nl ;;
"getESP" ' rsp alias
Root
: set ( vari val ) vari @ val @ = ;; //'set wdiss
: get ( vari -- TOS ) vari @ @ ;; //'get wdiss
"x1" var set ( x1 876543 ) get ( x1 ) dup dup nl p nl 876543 _assert x1 @ _assert //pause
"User" namespace
User
//: pause nl "pausing at :" ddps location nl _pause ;
: pause nl _pause ;
//: pause _pause ;
: opOff optimizeOff inlineOff state ;
: opOn1 optimizeOn inlineOn { verbosity @ 1 > } { state } if ;
// ' opOn1 wdiss
: vck ( n w ) { verbosity @ n @ > } { w @ wordRun drop } if2 ;
: opOn 
    optimizeOn inlineOn 
    1 ' state literal vck  
;
// ' opOn @ winfo
// opOn
"s" ' stack alias
// : s stack location pause ;
// : s stack dbg ;
"istring" ' interpretString alias
"def" ' word alias
Compiler
">;" ' >? alias

Root C
"allot" ' allocateMem alias
// : include location s include location s pause ;
// : include location nl include ;

: include1 dup debugColors "\n'include'" ps ps " :: at :" ps location nl defaultColors sp include  ;
Debug
#if ( DebugFlag @ )
: s stack alertColors location defaultColors ;
// : s stack alertColors location defaultColors ;
// : include 1 timerInit info stack include stack 1 time ; 
// : include include stack ;
// : include ( f ) vb3 alertColors decimal nl location nl "Entering : " ps f @ ps nl s f @ include defaultColors ;
: include include1 debugColors "location :" ps location nl defaultColors ;
vb3
#endif
: ds: stack _d: ; debugWord
Interpreter
: defined find ;
C Compiler Int Lexer
: ofile ( name | file input result )
    input 0 =
    "open/read/print :: " ps name @ ps nl
    file name @ fopen =
    nl { result file @ input 1 fread = input @ emit } { result @ 1 == } doWhile 
    file @ fclose
; prefix
Root
: license ofile ( "./LICENSE" ) ;

OpenVmTil
: lispOff "Lisp" notUsing ; //lcReset ;
: bigNumOff "BigFloat" notUsing "BigInt" notUsing ;

c_syntaxOff

stringMacrosOn
System
//s: assertStkChk <dbg> mem assertStkChk location pause ;s
: testCfrTil "namespaces/init.cft" include ;
: sp ; // stack pause ;
sp 
//Zenfone2 1 =
//mem pause
: sh _sh ; prefix
#if 1
String 
s: $$ 
    ""
    { token dup ";" strcmp } 
    { 
        { dup "." strcmp } { strcat " " strcat } { strcat } if3
    } 
    while drop location "$$" ps dup ps _sh return
;s  // allows more than one shell command on a ';' separated line 
"streol" 'getStringToEndOfLine alias
: $ streol _sh ;  
//'$$ wdiss pause
#if 0
$$ls -al /usr/local ; $$ls -al . ; 
$./script 
$./lispScript 
//pause
#endif
#endif


testCfrTil
stringMacrosOff
//demo

2 + 7 assertStkChk // stack checking
#if 0
String
$$ls -al /usr/local ; $$ls -al . ; 
$./script 
$./lispScript ; 
//pause
: hi 1 2 + p ; hi nl
$ls  -al ;
#endif
//Lisp words pause
s
