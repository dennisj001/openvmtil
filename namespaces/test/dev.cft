
5
optimizeOn inlineOn 
// optimizeOff inlineOff
// verbosity 2 = 
Compiler Logic Int C User C
// : sp stack pause ;
var: facTest fibTest Dsp ;
#if  0
 * - tail recursion from http://c2.com/cgi/wiki?TailCallOptimization
 * int factorial( int n )
 {
	int rec1 = 1;
	while ( n >= 2 )
		rec1 *= n--;
	return rec1;
 }
: factorial ( n  | fac -- TOS ) 
    fac 1 = 
    { n @ 1 > } { n @ fac @ * fac store n -- } while 
    fac @ 
;
#endif
: qexp dup 1 <= if{ }else{ dup -- qexp * }fi ;
: qexp2 dup 1 <= ?< >:< dup -- qexp2 * >? ;

: bexp ( n ) n @ 1 > if{ n @ dup -- bexp * }else{ 1 }fi ;
: bexp2 ( n ) { n @ 1 > } { n @ dup -- bexp2 * } { 1 } ifElse ;
: bexp3 ( n ) { n @ 1 > } { n @ n @ -- bexp3 * } { 1 } ifElse ;
7 bexp3 p
#if 1
c_syntaxOn
int
fac5 ( n  | facc -- TOS ) 
{ 
    facc = 1 ;
    while ( n > 1 ) 
    {
        facc = n * facc ;
        n -- ; 
    }
}
wdiss ( ' fac5 ) ; 

#if 0
fac5 ( 7 ) p 
int
faccs ( REG: n | EAX: rec -- EAX ) 
{
    rec = 1 ; 
    while ( n > 1 )
    { 
        //rec = rec * n-- ; // ?! c syntax rearranges the operators and we have * -- in this case now
        rec = rec * n ; 
        n -- ;
    } 
}
' faccs wdiss
faccs ( 7 ) p 

int
faccs2 ( REG: n | EAX: rec -- EAX ) 
{
    for ( rec = 1 ; n > 1 ; n-- )
    { 
        rec = rec * n ; 
    } 
}
' faccs2 wdiss
faccs2 ( 7 ) p 
#endif
c_syntaxOff

#endif

: fac ( n  | rec1 -- TOS ) 
    rec1 1 = 
    { n @ 1 > } { n @ rec1 @ * rec1 store n -- } while 
    rec1 @ 
;
// : bexp2 ( n | rec1 ) { n @ 1 <= } { 1 } { n @ dup -- bexp2 * } ifElse ;

: sdbg ( j ) { stackDepth 20 > } { state regs nl "stackDepth = " ps stackDepth p nl hex { j stackDepth = } { j @ 0 > } { j -- } { p } for quit } if2 ;

User
: factorial ( REG: n | EAX: rec -- EAX ) rec 1 = { n @ 1 > } { rec @ n @ * rec store n -- } while ;
: _ifx ( w | j ) 
    { j 1 = } { j @ 15 <= } { j ++ } 
    {
       // j @ w @ wordRun j @ p "." ps p ";" ps
       j @ w @ wordRun drop // j @ p "." ps p ";" ps
    }
    for
;

: iFactorialX ( n w | k ) { k 1 = } { k @ n @ <= } { k ++ } { w @ _ifx } for ; 

: _ffx ( n w | t ) nl 7 w @ wordRun decimal p nl { t 0 = } { t @ n @ < } { t ++ } { 100000 w @ iFactorialX } for ;
nl "ffx ... " ps nl
: nlpsnl ( str n ) hex nl str @ ps n @ p nl ;;
// "ffx" ( w ) { w dup @ find = w @ wdiss 3 w @ nlpsnl ( "w =" w @ ) _ffx } word
// "ffx" ( w | d ) { d w @ find = d @ wdiss nlpsnl ( "word =" d @ ) 7 d @ _ffx } word
: ffx ( w | d ) 1 ti d w @ find = d @ wdiss 3 d @ _ffx 1 time ;

#if log
logOn
' factorial wdiss
' _ifx wdiss
' iFactorialX wdiss
' _ffx wdiss
' ffx wdiss
facTest 1 = fibTest 1 =

#if 1 // ( facTest @ )
User
"factorial" ffx
sp
"cfactorial" ffx
"cfactorial2" ffx
User "qexp" ffx
C "bexp" ffx
"bexp2" ffx
"factorial" ffx
C "qexp" ffx
C "qexp2" ffx
"bexp" ffx
"bexp2" ffx
"bexp3" ffx
"fac" ffx
// "fac5" ffx pause
User
"factorial" ffx
"cfactorial3" ffx
"cfactorial" ffx
"cfactorial2" ffx
"cfactorial3" ffx
using  
"factorial" ffx
//"faccs" ffx
sp
#endif

logOff
#endif
C
#if 1 // fibTest @ 
: tt ( | t ) t 6 = t ++ t @ p ;
' tt dup source code dup wdis iax
#if 1
c_syntaxOn
int 
_fibn0 ( n ) 
{
    if ( n < 2 ) 
    {   
        return ( n ) ;
    }
    else 
    {
        return (  _fibn0 ( n - 1 ) + _fibn0 ( n - 2 ) ) ;
    }
}
' _fibn0 wdiss _fibn0 ( 20 ) p 
c_syntaxOff
#else
infixOn prefixOn
: _fibn0 ( REG: n | -- RETURN_TOS ) { n < 2 } { n } { _fibn0 ( -- n ) <dbg> + _fibn0 ( -- n  )  } ifElse ;
' _fibn0 wdiss d: _fibn0 ( 4 ) p sp
infixOff prefixOff
#endif
: _fib1 ( n ) { n @ 2 < } { n @  } { n @ -- _fib1 n @ 2 - _fib1 + } ifElse ;
: _fib 
    dup 2 < 2 
    if{ 
    }else{ 
        dup -- _fib swap 2 - _fib + 
    }fi 
;

: _fib2 dup 2 < ?< >:< dup -- _fib2 swap 2 - _fib2 + >; ; //d: 5 _fib2 p

: _fib3 
    dup 2 < 2 
    ?< 
    >:< 
        dup -- _fib3 swap 2 - _fib3 + 
    >; 
;
' _fib3 wdiss
20 _fib3 p
Locals
"fib1" ( n ) { 1 ti n @ _fib1 p 1 time } word
C
: fib  ( n ) 1 ti n @ _fib  p 1 time ;
: fib2 ( n ) { 1 ti n @ _fib2 p 1 time ;
: fib3 ( n ) { 1 ti n @ _fib3 p 1 time ;
: fibn0 ( n ) { 1 ti n @ _fibn0 p 1 time ;
: Cfib ( n ) 1 ti n @ cfib  p 1 time ;
: tfib ( n )  
    nl hex Dsp p decimal nl "The fibonacci sequence" ps n @ p ":" ps nl 
    "C -O3 : " ps n @ Cfib nl 
    "no locals fib  : " ps n @ fib nl 
    "locals fibn0 : " ps n @ fibn0 nl 
    "locals fib1  : " ps n @ fib1 nl 
    "no locals fib2 : " ps n @ fib2 nl
    "no locals fib3 : " ps n @ fib3 
;
// 15 tfib 30 tfib 40 tfib 45 tfib 
: tfib1 ( n | m )  
    nl "The fibonacci sequence:: first :" ps n @ p "..." ps nl 
    "Cfib           : " ps 1 ti m 1 = { m @ n @ < } { m @ cfib p m ++ } while 1 time nl nl
    "no locals fib  : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib p m ++ } while 1 time nl nl 
    "locals   fibn0 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fibn0 p m ++ } while 1 time nl nl
    "locals   fib1  : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib1 p m ++ } while 1 time nl nl
    "no locals fib2 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib2 p m ++ } while 1 time nl nl
    "no locals fib3 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib3 p m ++ } while 1 time nl nl
;
30 tfib1
: fibx ( n ) { n @ 0 >= } { n @ _fib p n -- } while ;
: fibx2 ( n | m ) "fibonacci" ps n @ p ":" ps m 0 = { m @ n @ < n @ <= } { m @ n @ < _fib2 p m ++ } while ;
// : fibx3 ( n | m ) "fibonacci" ps n @ p ":" ps m 0 = { m @ n @ < n @ <= } { m @ n @ < _fib3 p m ++ } while ;
: fibx3 ( n ) "fibonacci" ps n @ p ":" ps { n @  } { n @ _fib3 p n -- } while ;
// ' _fib wdiss
' _fib2 wdiss
// 40 fibx3 
' _fibn wdiss
Lisp (fib 20)
"Lisp" notUsing
#endif
nl
2 + 7 assertStkChk // stack checking
// verbosity 1 =
// namespaceTreeWithWords
s
