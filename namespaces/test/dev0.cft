
5
opOn // this currently requires the optimization to be on to compile correctly 
// verbosity 2 = 
// echoOn
: stp ; //stack pause ;
stp
User
"Experimental" namespace
C Experimental Bits
: ll ( dir ) "$ ls -al " dir @ strcat istring ;;
: llc "$ ls -al " istring ;
Shell
llc
ll ( "/home" )
'Shell notUsing sp
// constant folding optimization test
: tx 4 2 / 5 + ; tx 7 _assert
// ' tx wdiss 
Logic 
// test constant folding
: tx1 0 ! ! 8 2 / 2 / 3 & 4 | 1 + + ; tx1 7 _assert
// ' tx1 wdiss pause

// namespaceTreeWithWords

C
#if 0 // - tail recursion from http://c2.com/cgi/wiki?TailCallOptimization
int factorial ( int n )
{
       int rec1 = 1;
       while ( n >= 2 ) rec1 *= n--;
       return rec1;
}
#endif

: fac ( n  | rec1 -- TOS ) 
    rec1 1 = 
    { n @ 1 > } { n @ rec1 @ * rec1 store n -- } while 
    rec1 @ 
;
// ' fac wdiss
7 fac dup p 5040 _assert

// doDemo @ #if
#if 1
state
: factorial ( REG: n | EAX: rec -- EAX ) rec 1 = { n @ 1 > } { rec @ n @ * rec store n -- } while ;
_wdiss ( 0 tick factorial literal )
7 factorial dup p 5040 "factorial" assert1
#endif

// nl location "\nstarting Lisp\n stack is ..." ddps s
nl location "\nstarting Lisp ..." ddps s
Lisp 
( define g23 ( lambda ( a b c ) ( a b c))) 
tick g23 wdiss
(g23 + 3 4 ) (g23 / 14 2 ) 
(define q1x0 (/\ (a0) (a0))) 
tick q1x0 wdiss

((q1x /) 14 2)
(define h01 (lambda (a) (a)))
((h01 /) 14 2)
tick h01 wdiss

(t+ 1 2 3 1) 
stp
// BigFloat
(define average (/\ ( n0 n1 )(/ ( + n0 n1 ) 2 )))
( average 52 102 )

// TODO : somehow average is not working after startup ?
(+ 1 6)

(define fib (lambda (n) ( ifElse (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))
(define fib2 (lambda (n) (ifElse (< n 2) n (+ (fib2 (- n 1)) (fib2 (- n 2))))))
tick fib wdiss // pause

// pause
(fib 20) (fib2 20)
// pause
(if* 1 7 2)
(+ 2 5)


(define g1 (lambda (a1 b1 c1)(a1 b1 c1))) 
(define g2 (/\(a b c)(a b c))) 
(g + 3 4 )(g / 14 2 )
( define j ( lambda ( a b c ) ( + a b c)))
( define h ( lambda ( a b c ) ( + a b c)))
( define k ( lambda ( a b ) ( + a b )))
nl
( k ( j 1 2 3 ) ( h 2 3 66 ) ) // 77 ...
( + ( k ( j 1 2 3 ) ( h 2 3 66 ) ) ( + 698 2 ) ) // 777
( + ( k ( j 1 2 3 ) ( h 2 3 59 ) ) 7 ) // 77
( g + ( k ( j 1 2 ( h 2 3 ( k 59 4 ) ) ) 6 ) 0 ) // 77
// pause
"\nbefore fib" ddps


( - ( + 1 2 ( * 3 4 ) ( / 4 2 ) ( - 9 8 ) 10 770 787 34 ) 21 787 34 )  // == 777
#endif
1 #if // demo : interspersing C code with lisp compiled code
C Compiler
: _fib1 ( n ) { n @ 2 < } { n @  } { n @ -- _fib1 n @ 2 - _fib1 + } ifElse ;
// ' _fib1 wdiss
20 _fib1 p
#endif
Lisp
optimizeOff
(define fibc (lambda ( n ) (ifElse (< n 2) n (+ (fibc (- n 1)) (fibc (- n 2))))))
(fibc 20)
optimizeOn
(define fibco (lambda ( n ) (ifElse (< n 2) n (+ (fibco (- n 1)) (fibco (- n 2))))))
tick fibco wdiss // have to use 'tick' not ' - remember we are in the Lisp namespace
(fibco 20)
"\nafter fib" ddps nl

#if 1 // testing
lispOff
doDemo @ #if
Compiler C
: _fib1 ( n ) { n @ 2 < } { n @  } { n @ -- _fib1 n @ 2 - _fib1 + } ifElse ;
// ' _fib1 wdiss
 20 _fib1 p
: _fibn ( n ) { n @ 2 < } { n @  } { n @ -- _fibn n @ 2 - _fibn + } ifElse ;
// ' _fibn wdiss
20 _fibn p
#endif

Int
Lisp
(define fibc2 ( lambda ( n ) ( ifElse ( < n 2 ) n ( + ( fibc2 ( - n 1 ) ) ( fibc2 ( - n 2 ) ) ) ) ) )
// ' fibc2 wdiss
(fibc2 20)

#endif // testing

(define fibco1 (lambda (n ) (ifElse (< n 2) n (+ (fibco1 (- n 1)) (fibco1 (- n 2))))))
// tick fibco1 wdiss
(fibco1 20)

(define x7 (7 8 9 45))
nl (list 1 2 3 `x7)
nl (list 1 2 3 `,x7 )
nl (list 1 2 3 x7 )
nl (list 1 2 3 @x7 )
nl (list 1 2 3 ,@x7 )
nl (+ 1 3 4 ,@x7) 
(+ 1 3 4 @x7) 
(+ 1 3 4 `,@x7) 
(define alist (list 1 2 3 ,@x7)) 
//pause

stp
//BigInt : TODO : BigInt/BigFloat can work 
(define yfac (lambda (yy n) (if* (< n 2) 1 (* n (yy yy (- n 1)))))) // code from : http://www.newlisp.org/index.cgi?Y_Function
// tick yfac wdiss
(yfac yfac 10) nl
(define yfacc (lambda (yyy n1) (if* (< n1 2) 1 (* n1 (yyy yyy (- n1 1)))))) 
// tick yfacc wdiss
(yfacc yfacc 10) nl
(yfacc yfacc 7) nl
stp
#if 0
BigInt
(define yfac (lambda (yy n) (if* (< n 2) 1 (* n (yy yy (- n 1)))))) // code from : http://www.newlisp.org/index.cgi?Y_Function
// tick yfac wdiss
(yfac yfac 10) nl
(define yfacc (lambda (yyy n1) (if* (< n1 2) 1 (* n1 (yyy yyy (- n1 1)))))) 
// tick yfacc wdiss
(yfacc yfacc 10) nl
(yfacc yfacc 7) nl
bigNumOff
#endif
stp

(define x "let") (define a "the") // 'let' is a special word
(define x1 'let) (define a1 the)
stp
nl ( Its 'a beautiful day don\'t 'let it get away )
nl '( Its a beautiful day don\'t let it get away )
nl '( Its a beautiful day don\'t @x1 it get away ) 
nl `( ,Its ,a ,beautiful ,day ,don\'t ,@x1 ,it ,get ,away )
nl `( Its ,a beautiful day don\'t ,x it get away )
nl `( Its 'a beautiful day don\'t ,x1 it get away )
nl `( Its a beautiful day don\'t ,@x it get away )
nl `( Its a beautiful day don\'t ,@x1 it get away )
stp
(define ff ( lambda (n) (+ n 1)))
((/\ (x) (+ x 1)) 6 ) ((/\ (x) (+ x 1)) ((/\ (y) (+ y 2)) 4 ) )
(ff 6)
(average 12 2) 
lispOff 
Lisp
(average 12 2) 
stp
(define h36 (lambda (a b) (a b a b a a b b)))
(h36 n09 my6 ) 
(define n09 kl0 ) (define my6 op9 )
(h36 n09 my6 )
stp

// macro experiments
: sp ; //stack pause ;
( define id (lambda ( a b ) ( a a b b )) )
( id a b ) 
( define id1 ( lambda ( a12 b13 ) ( a12 a12 b13 b13 a12 a12 ) ) )
nl ( id1 7 8 )
( macro swch ( lambda ( a2 b2 ) ( b2 a2 ) ) )
( macro swch2 ( lambda ( a2 b2 ) ( (swch b2 a2) (swch b2 a2 ) ) ) )
nl ( swch2 7 8 )
( macro id2 ( lambda ( a2 b2 ) ( ( swch2 b2 a2 ) ( swch2 b2 a2 ) ) ) )
nl ( id2 7 8 )
( macro id3 ( lambda ( a12 b13 ) ( a12 a12 b13 a12 b13 b13 a12 a12 ) ) ) 
nl ( id3 7 8 )
( macro swch3 ( lambda ( a2 b2 ) ( (swch2 b2 a2) (swch2 b2 a2 ) ) ) )
( macro id4 ( lambda ( a12 b13 ) ( a12 a12 (swch3 a12 b13 ) b13 b13 a12 a12 ) ) ) 
nl ( id4 7 8 ) 
// pause
(define x (swch2 3 4) ) 
( macro id4 ( lambda ( a12 b13 ) ( a12 a12 @x b13 b13 a12 a12 ) ) ) 
( id4 7 8 )
(define x (swch 8 15) )  ( - @x) 
(define x (swch 8 19) )  ( - @x) 


lispOff
List
//nl d: _((lambda ( a b) (+ a b)) 3 4 ) dupList eval printList printList s lcReset
2 + 7 assertStkChk // stack checking
"\nending Lisp\n stack is ..." ddps s
// opOff
// demo d: "bexp3" ffx
