
5
#if _TestDone_ @ not // prevent including twice
decimal
User
C
// nb. this is some of the oldest testing junk
// demonstrate calling order of local variables
: a123 ( one two three )

    one @ p
    two @ p
    three @ p
;
1 2 3 a123 nl
: a1234 ( one two three four )

    one @ p
    two @ p
    three @ p
    four @ p
;;
a1234 ( 1 2 3 4 )

: hey ( n m | o q )
	nl "startHey" prints
	o m @ = 	"o =" ps o @ print "m =" ps m @ print
	q n @ =  	"q =" ps q @ print "n =" ps n @ print 
	n @ m @ o @ q @ + + + dup print 26 _assert
	n @ m @ + o @ + q @ + dup print 26 _assert
        " after hey" ps 
;
' hey wdiss 

6 7 hey 
: hey1 ( a b -- TOS ) a @ b @ hey ; 
6 7 hey1 p

: hey2 ( n m | o q -- TOS )
 	nl "startHey2" prints
	m @ o store     "o =" ps o @ print "m =" ps m @ print
	n @ q store     "q =" ps q @ print "n =" ps n @ print 
        n @ m @ hey 
	n @ m @ + o @ + q @ + dup print 
        " afterHey2" prints
;
6 7 hey2 p

nl "beforeHeey" prints

: heey ( a b ) a @ b @ hey2 p a @ b @ hey2 ;
: heey2 ( a b ) a @ b @ heey a @ b @ heey ;
: heeey2 ( a b ) a @ b @ heey2 a @ b @ heey2 ;
: heeeey2 ( a b ) a @ b @ heeey2 a @ b @ heeey2 ;
6 7 heey 
6 7 heey2 
6 7 heeeey2 
nl "afterHeey" prints
decimal

hex
Class DLLNode
DLLNodeAlloc
: tna2x ( this | t1 )
        t1 this =  
        this p t1 p t1 @ p
        nl "this = " ps this p nl nl "t1 @ = " ps t1 @ p nl "t1 = " ps t1 p
        nl "done showing variables" ps nl
	this.nodes [ 1 ].AfterReference 1 = 
	this.nodes [ 3 ].BeforeReference 3 =
	this.nodes [ 4 ].BeforeReference 4 =
	this.nodes [ 2 ].AfterReference 2 = 
	this.nodes [ 5 ].BeforeReference 5 =
	this.nodes [ 6 ].BeforeReference 6 =
	this.nodes [ 7 ].BeforeReference 7 =
	t1 @ DLLNode.size @ 8 * dump 
;
"testA1" DLLNodeAlloc new
"testB1" DLLNodeAlloc new
nl "testA1 = " prints testA1 dup print nl tna2x //pause

Class DLLNode
DLLNodeAlloc
"testA2" DLLNodeAlloc new
"testB2" DLLNodeAlloc new
testA2.nodes [ 1 ].AfterReference 3 =
testA2.nodes [ 3 ].BeforeReference 4 =
testA2 32 dump
testA2.nodes [ 1 ].AfterReference 3 =
testA2.nodes [ 3 ].BeforeReference 4 =
testA2.nodes [ 1 ].AfterReference @ p
testA2.nodes [ 3 ].BeforeReference @ p

"before test" nl ps nl
testA2.nodes [ 3 ].BeforeReference @ 4 using Logic.== { nl "array test ok" ps } { nl "array test error" ps } tf2 nl p

testA2 32 dump
testB2.nodes [ 1 ].AfterReference 5 =
testB2.nodes [ 3 ].BeforeReference 6 =
testB2 32 dump
"testD" DLLNodeAlloc new
'testD dobject
testD.a112.b113 77 =
"testC" 'testD DObject.clone 
testC.a112.b113 @ p

User
hex
: _localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
;

: localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
        t @ _localsT
        t1 @ _localsT
;

1 localsT

Combinators User
decimal
"\n\ntesting nested locals" ps
: goedel { (| n ) n 1 = n @ 6 + dup 7 _assert p } ix { (| m ) m 3 = m @ 4 + dup 7 _assert p } ix ;
: goedel2 { (| n ) n 2 = n @ 5 + dup 7 _assert p } ix { (| n ) n @ p n 3 = n @ 4 + dup p 7 _assert } ix ;
nl "goedel2 :: " ps goedel2 

: goedel4 (| n -- TOS ) 
    n 9 =
    { 
        (| n ) n @ p n 2 = n @ dup p 2 _assert // n should be garbage here
        { (| n ) n @ p n 3 = n @ 4 + dup p 7 _assert } ix // n should be garbage here
        n @ 6 + 8 _assert 
    } ix
    { (| n ) n @ p n 3 = n @ 4 + 7 _assert } ix // n should be garbage here
    n @ dup p
;
//' goedel4 wdiss 
nl "goedel4 :: " ps nl
goedel4 9 _assert 
"\nabove output should read : \n'anything' 2 'anything' 7 'anything' 9" ps //pause

#endif

2 + 7 assertStkChk // stack checking

