
5

decimal
User
C
// nb. this is some of the oldest testing junk
// demonstrate calling order of local variables
: a123 ( one two three )

    one @ p
    two @ p
    three @ p
;
1 2 3 a123 nl
: a1234 ( one two three four )

    one @ p
    two @ p
    three @ p
    four @ p
;;
a1234 ( 1 2 3 4 )

: hey ( n m | o q )
	nl "startHey" prints
	o m @ = 	nl "o = " ps o @ print nl "m = " ps m @ print
	q n @ =  	nl "q = " ps q @ print nl "n = " ps n @ print nl
	n @ m @ o @ q @ + + + dup print 26 _assert p
	n @ m @ + o @ + q @ + dup print 26 _assert
        nl "after hey" ps 
;
' hey wdiss 

6 7 hey 
: hey1 ( a b -- TOS ) a @ b @ hey ; 
6 7 hey1 p

: hey2 ( n m | o q -- TOS )
 	nl "startHey2" prints
	m @ o store     nl "o = " ps o @ print nl "m = " ps m @ print
	n @ q store     nl "q = " ps q @ print nl "n = " ps n @ print nl
        n @ m @ hey 
	n @ m @ + o @ + q @ + dup print 
        nl "afterHey2" prints nl
;
6 7 hey2 p

nl "beforeHeey" prints nl

: heey ( a b ) a @ b @ hey2 p a @ b @ hey2 p ;
: heey2 ( a b ) a @ b @ heey a @ b @ heey ;
: heeey2 ( a b ) a @ b @ heey2 a @ b @ heey2 ;
: heeeey2 ( a b ) a @ b @ heeey2 a @ b @ heeey2 ;
6 7 heey 
6 7 heey2 
6 7 heeeey2 
nl "afterHeey" prints nl
decimal

#if 0 // this test may be useless ?? and is not working but is somehow interesting
hex
Class DLLNode
DLLNodeAlloc
: tna2x ( this | t1 )
        <dbg> d: t1 this =  
        this p t1 p
        nl "this = " ps this p nl nl "t1 @ = " ps t1 @ p nl "t1 = " ps t1 @ p
        nl "done showing variables" ps nl
	d: t1 . nodes [ 1 ].AfterReference 3 = 
	t1 . nodes [ 3 ].BeforeReference 4 =
	t1 . nodes [ 4 ].BeforeReference 5 =
	<dbg> t1 32 dump 
;
"testA" DLLNodeAlloc new
"testB" DLLNodeAlloc new
nl "testA = " prints testA dup print nl d: tna2x pause
#endif

#if 1

Class DLLNode
DLLNodeAlloc
"testA" DLLNodeAlloc new
"testB" DLLNodeAlloc new
testA.nodes [ 1 ].AfterReference 3 =
testA.nodes [ 3 ].BeforeReference 4 =
testA 32 dump
testA.nodes [ 1 ].AfterReference 3 =
testA.nodes [ 3 ].BeforeReference 4 =
testA.nodes [ 1 ].AfterReference @ p
testA.nodes [ 3 ].BeforeReference @ p

"before test" nl ps nl
testA.nodes [ 3 ].BeforeReference @ 4 using Logic.== { nl "array test ok" ps } { nl "array test error" ps } tf2 nl p

testA 32 dump
testB.nodes [ 1 ].AfterReference 5 =
testB.nodes [ 3 ].BeforeReference 6 =
testB 32 dump
#endif

#if 1
User
hex
: _localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
;

: localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
        t @ _localsT
        t1 @ _localsT
;

1 localsT
#endif

// nested nameaces test
Combinators User
decimal
: goedel { (| n ) n 1 = n @ 6 + dup 7 _assert p } ix { (| m ) m 3 = m @ 4 + dup 7 _assert p } ix ;
: goedel2 { (| n ) n 2 = n @ 5 + dup 7 _assert p } ix { (| n ) n @ p n 3 = n @ 4 + dup p 7 _assert } ix ;
nl "goedel2 :: " ps goedel2 

: goedel4 (| n -- TOS ) 
    n 9 =
    { 
        (| n ) n @ p n 2 = n @ dup p 2 _assert // n should be garbage here
        { (| n ) n @ p n 3 = n @ 4 + dup p 7 _assert } ix // n should be garbage here
        n @ 6 + 8 _assert 
    } ix
    { (| n ) n @ p n 3 = n @ 4 + 7 _assert } ix // n should be garbage here
    n @ dup p
;
' goedel4 wdiss 
nl "goedel4 :: " ps 
goedel4 9 _assert 
"\nabove output should read : \n'anything' 2 'anything' 7 'anything' 9" ps 

2 + 7 assertStkChk // stack checking

