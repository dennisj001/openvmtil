
5 
System Interpreter 
#define thi ( ) 1 2 + p 
#define the0 "thi1 ="  
#define the1 nl \
             ps // backslash also works like C #define 
#define thi01 the0 the1
#define thi1 1 2 \
    + p 
: sp ; //stack pause ;
 
infixOn
sp
#define thi() 1 + 2 p()
#define thi0() 1 + 2 p
c_syntaxOn
#define thii() p (1 + 2) 
void
testc1 ( | atoken aword ) 
{
    int tdbg = 1, tdbg2 = 2, tdbg3 = 3 ; 
    int tdbg4 = 4, tdbg5 = 5, tdbg6 = 6 ; 
    ps ( "\ntdbg =" ) ; p ( tdbg ) ; 
    ps ( "\ntdbg2 =" ) ; p ( tdbg2 ) ; 
    ps ( "\ntdbg3 =" ) ; p ( tdbg3 ) ; //pause () ;
    ps ( "\ntdbg4 =" ) ; p ( tdbg4 ) ; 
    ps ( "\ntdbg5 =" ) ; p ( tdbg5 ) ; 
    ps ( "\ntdbg6 =" ) ; p ( tdbg6 ) ; //pause () ;
    ps ( "\nthii =" ) ; thii () ; thi0(); thi1 ; thi(); thi01 ; thi1 ; 
}
//'testc1 wdiss pause 
testc1 () ; //pause

void
interpret2 ( | atoken aword ) 
{
    testc1 () ; thi01 ; thi1 ; //pause () ;
    //nl() ; tab () ; ps ( "interpret2 :> " ) ; nl () ;
    while ( 1 )
    {   
        atoken = token () ; 
        //printf ( "\n\ttoken = %s", atoken ) ; 
        if ( ! ( strcmp ( atoken, "i2halt" ) ) ) 
        { 
            return ; 
        }
        else
        {
            if ( atoken )
            {       
#if 0
                // printf ( "\n\ttoken = %s", atoken ) ; 
                aword = find ( atoken ) ; 
                if ( aword )
                { 
                    doMorphismWord ( aword ) ; // can do it all -- compile itself, c syntax, etc.
                } 
                else 
                { 
                    literalInterpret (atoken ) ;
                } 
#else
                aword = tokenToWord ( atoken ) ;
                doWord ( aword ) ;
#endif
            }       
        }
    }
}
' interpret2 wdiss 
sp
interpret2 
c_syntaxOff sp
#if 1
: hi1 1 2 + p ;  
: hey1 hi1 hi1 ; 
: heey1 hey1 hey1 hey1 ;
nl heey1 
#endif
i2halt
"C_Combinators" notUsing
infixOff
sp
2 + 7 assertStkChk // stack checking

