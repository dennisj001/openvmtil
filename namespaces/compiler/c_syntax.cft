5 
// maybe we're shooting for a "smart syntactic language" that will parse "poetic" syntactic arrangements
#if 1
optimizeOn inlineOn 
System Interpreter Combinators C C_Combinators
C
sl
#if Zenfone2 @ not
dlsym: strcmp /lib32/libc.so.6 ;
dlsym: sprintf /lib32/libc.so.6 ;
dlsym: printf /lib32/libc.so.6 ; void_return
#endif
User
// : sp sl pause ;
c_syntaxOn
#if 1
typedef _CObj
{
    int hi ;
    char chars [ 32 ] ;
    int hey ;
    int heey2 ;
    //quad heey ;
    int heey1 ;
} cobj, CObj ;
p ( CObj.size ) ;
"chey" CObj new 
CObj
chey.hi = 1234 ;
chey.chars [2] = 255 ;
//chey.heey = #x123456789abcdef ;  
chey.heey1 = #x12345678 ; 
#if 1
chey.heey2 = chey.heey1 ; // #x12345678 ; 
chey.hey = chey.heey2 ; // #x12345678 ;
#else
chey.heey2 = #x12345678 ; 
chey.hey = #x12345678 ;
#endif
chey.chars [23] = 255 ;
chey.chars [18] = #b10110 ; // #x16
dump ( chey, cobj.size ) ; 
p ( cobj.size ) ; 
' chey hex p
// d: logOn sl using
void
chi ( chey0, d | a b c )
{
    c = 1 + 2 ;
    b = c + 2 ;
    a = b + c ;
    p ( c ) ; c @ 3 "c should be 3" assert // 3
    p ( b ) ; b @ 5 "b should be 5" assert // 5
    p ( a ) ; a @ 8 "a should be 8" assert // 8
#if 0
    d = cobj.chey0.hey ;
    sprintf ( & cobj.chey0.chars, "\nhey = %d", d ) ; 
    sprintf ( & cobj.chey0.chars, "\nhey = %d", cobj.chey0.hey ) ;
#endif
    printf ( "\n %d\n", d ) ;
    d = cobj.chey0.hey ;
    printf ( "\n%x\n", d ) ;
    printf ( "\n%x\n", cobj.chey0.hey ) ;
    dump ( &cobj.chey0, cobj.size ) ; 
}
// logOff
wdiss ( ' chi ); 
chi ( chey, 7 ) ; 
sp
#endif

void
interpret2 ( | atoken aword ) 
{
    nl tab () ; ps ( "interpret2 :> " ) ; nl
    while ( 1 )
    {   
        //<dbg>
        atoken = token () ; drop () ;
        if ( ! ( strcmp ( atoken, "i2halt" ) ) ) 
        { 
            return ; 
        }
        else
        {
            if ( atoken )
            {       
                printf ( "\n\ttoken = %s", atoken ) ; 
                aword = find ( atoken ) ; drop () ;
                if ( aword != 0 )
                { 
#if 0
                    // <dbg>
                    setupWordEval ( aword ) ;
                    if ( ( ! ( compileMode_get () ) ) || ( ?immediate ( aword ) ) )
                    { 
                        dup () ;
                        wordEval ( aword ) ; 
                    } 
                    else 
                    { 
                        dup () ;
                        _compileWord ( aword ) ;
                    }
#else
                    doMorphismWord ( aword ) ; // can do all -- compile itself, c syntax, etc.
#endif
                } 
                else 
                { 
                    literalInterpret (atoken ) ;
                } 
            }       
        }
    }
}
wdiss ( ' interpret2 ) ;
interpret2 
using
int
fac4 ( n  | facc -- TOS ) 
{ 
    facc = 1 ;
    while ( n > 1 ) 
    {
        facc = n-- * facc ;
    }
    // p ( facc ) ;
    return ( facc ) ;
}
wdiss ( ' fac4 ) ; 
fac4 ( 7 ) p // s pause

User
c_syntaxOff
'interpret3 'interpret2 alias
interpret3 words // i2halt code to exit interpret2

: hi1 1 2 + p ;  
: hey1 hi1 hi1 ; 
: heey1 hey1 hey1 hey1 ;
nl heey1 
#if 0
c_syntaxOn
int
faccs2 ( REG: n | EAX: rec -- EAX ) 
{
    for ( rec = 1 ; n > 1 ; n-- )
    { 
        rec = rec * n ; 
    } 
}
' faccs2 wdiss
faccs2 ( 7 ) p sp
c_syntaxOff
#endif

i2halt // see above in interpret2
i2halt // for second interpret2 
sp
#endif
2 + 7 assertStkChk // stack checking

